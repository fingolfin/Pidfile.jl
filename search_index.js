var documenterSearchIndex = {"docs":
[{"location":"#Pidfile.jl","page":"Home","title":"Pidfile.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Pidfile","category":"page"},{"location":"","page":"Home","title":"Home","text":"Documentation for Pidfile.jl:","category":"page"},{"location":"","page":"Home","title":"Home","text":"A simple utility tool for creating advisory pidfiles (lock files).","category":"page"},{"location":"#Primary-Functions","page":"Home","title":"Primary Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"mkpidlock\nclose","category":"page"},{"location":"#Pidfile.mkpidlock","page":"Home","title":"Pidfile.mkpidlock","text":"mkpidlock([f::Function], at::String, [pid::Cint, proc::Process]; kwopts...)\n\nCreate a pidfile lock for the path \"at\" for the current process or the process identified by pid or proc. Can take a function to execute once locked, for usage in do blocks, after which the lock will be automatically closed. If the lock fails and wait is false, then an error is thrown.\n\nThe lock will be released by either close, a finalizer, or shortly after proc exits. Make sure the return value is live through the end of the critical section of your program, so the finalizer does not reclaim it early.\n\nOptional keyword arguments:\n\nmode: file access mode (modified by the process umask). Defaults to world-readable.\npoll_interval: Specify the maximum time to between attempts (if watch_file doesn't work)\nstale_age: Delete an existing pidfile (ignoring the lock) if its mtime is older than this.   The file won't be deleted until 25x longer than this if the pid in the file appears that it may be valid.   By default this is disabled (stale_age = 0), but a typical recommended value would be about 3-5x an   estimated normal completion time.\nrefresh: Keeps a lock from becoming stale by updating the mtime every interval of time that passes.   By default, this is set to stale_age/2, which is the recommended value.\nwait: If true, block until we get the lock, if false, raise error if lock fails.\n\n\n\n\n\n","category":"function"},{"location":"#Base.close","page":"Home","title":"Base.close","text":"close(lock::LockMonitor)\n\nRelease a pidfile lock.\n\n\n\n\n\n","category":"function"},{"location":"#Helper-Functions","page":"Home","title":"Helper Functions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pidfile.open_exclusive\nPidfile.tryopen_exclusive\nPidfile.write_pidfile\nPidfile.parse_pidfile\nPidfile.stale_pidfile\nPidfile.isvalidpid\nBase.touch(::Pidfile.LockMonitor)","category":"page"},{"location":"#Pidfile.open_exclusive","page":"Home","title":"Pidfile.open_exclusive","text":"open_exclusive(path::String; mode, poll_interval, stale_age) :: File\n\nCreate a new a file for read-write advisory-exclusive access. If wait is false then error out if the lock files exist otherwise block until we get the lock.\n\nFor a description of the keyword arguments, see mkpidlock.\n\n\n\n\n\n","category":"function"},{"location":"#Pidfile.tryopen_exclusive","page":"Home","title":"Pidfile.tryopen_exclusive","text":"tryopen_exclusive(path::String, mode::Integer = 0o444) :: Union{Void, File}\n\nTry to create a new file for read-write advisory-exclusive access, return nothing if it already exists.\n\n\n\n\n\n","category":"function"},{"location":"#Pidfile.write_pidfile","page":"Home","title":"Pidfile.write_pidfile","text":"write_pidfile(io, pid)\n\nWrite our pidfile format to an open IO descriptor.\n\n\n\n\n\n","category":"function"},{"location":"#Pidfile.parse_pidfile","page":"Home","title":"Pidfile.parse_pidfile","text":"parse_pidfile(file::Union{IO, String}) => (pid, hostname, age)\n\nAttempt to parse our pidfile format, replaced an element with (0, \"\", 0.0), respectively, for any read that failed.\n\n\n\n\n\n","category":"function"},{"location":"#Pidfile.stale_pidfile","page":"Home","title":"Pidfile.stale_pidfile","text":"stale_pidfile(path::String, stale_age::Real) :: Bool\n\nHelper function for open_exclusive for deciding if a pidfile is stale.\n\n\n\n\n\n","category":"function"},{"location":"#Pidfile.isvalidpid","page":"Home","title":"Pidfile.isvalidpid","text":"isvalidpid(hostname::String, pid::Cuint) :: Bool\n\nAttempt to conservatively estimate whether pid is a valid process id.\n\n\n\n\n\n","category":"function"},{"location":"#Base.Filesystem.touch-Tuple{Pidfile.LockMonitor}","page":"Home","title":"Base.Filesystem.touch","text":"Base.touch(::Pidfile.LockMonitor)\n\nUpdate the mtime on the lock, to indicate it is still fresh.\n\nSee also the refresh keyword in the mkpidlock constructor.\n\n\n\n\n\n","category":"method"}]
}
